# Learned Lessons

This document describes some of the things I learned about solidity and/or
Ethereum during this development cycle.

## Who can call a function?

Often, you will want to prevent others from modifying a function, for example
how much an investor can still receive as a ROI. Based on
[this](https://ethereum.stackexchange.com/a/137947) answer, with zero upvotes,
a typical way to do this is:

```sol
contract B {
  address addressA;

  modifier onlyACanCall() {
    require(msg.sender == addressA);
  }
  constructor(address _A) {
    addressA = _A;
  }
  function onlyA() external onlyACanCall {
      // ...
  }
}
```

Or you could make some contract Ownable. I did not yet look up what that is.

## SafeMath

As of solidity 0.8.x the SafeMath checks against overflow and underflow are
embedded in the compiler. This means you don't have to use the `a.mul()`
operations anymore, because the checks that are called in the `mul()` operation
of safemath, are done by the compiler. I don't know actually how that can be
done by the compiler when the values are coming in at runtime. Probably the
compiler embeds those checks in the generated bytecode, such that those checks
are performed at runtime automatically.

## Definitions

- **public** - all can access
- **external** - Cannot be accessed internally, only externally
- **internal** - only this contract and contracts deriving from it can access
- **private** - can be accessed only from this contract

As you can notice **private** is a subset of **internal** and **external** is
a subset of **public**.

## Order

```sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.0 <0.9.0;
contract A {
    constructor() {
        // ...
    }

    receive() external payable {
        // ...
    }

    fallback() external {
        // ...
    }

    // External functions
    // ...

    // External functions that are view
    // ...

    // External functions that are pure
    // ...

    // Public functions
    // ...

    // Internal functions
    // ...

    // Private functions
    // ...
}
```

## \_something (underscores)

I thought underscores before a variable were used because they are private.
And they are, or they are internal [Source](https://docs.soliditylang.org/en/latest/style-guide.html#underscore-prefix-for-non-external-functions-and-variables).

**Incorrect [source](https://ethereum.stackexchange.com/questions/56443/what-does-mean-before-a-variable-name)**
Instead they are used to not overwrite/"shadow" variables of the same name in
a contract. So incoming argument parameters are written with _ before them.
This **cannot** yield patterns like:

```sol
constructor(address[] _payees) public payable {
    payees = _payees
  }
```

where the internal variable `payees` is given the value of the incoming
argument `_payees`.

## Forge Testtokens

Use:

```sol
// Generate deterministic address.
address someAddress = address(uint160(uint256(keccak256(bytes("1")))));
deal(someAddress, 43 ether);
assertEq(someAddress.balance, 43 ether);
```

or:

```sol
deal(address(1), 43 wei);
assertEq(address(1).balance, 43 wei);
```

in your testfunction. The balances below were not found to be 1000 but 0 when checked.

```txt
Available Accounts

(0) "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266" (10000.000000000000000000 ETH)
(1) "0x70997970C51812dc3A010C7d01b50e0d17dc79C8" (10000.000000000000000000 ETH)
(2) "0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC" (10000.000000000000000000 ETH)
(3) "0x90F79bf6EB2c4f870365E785982E1f101E93b906" (10000.000000000000000000 ETH)
(4) "0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65" (10000.000000000000000000 ETH)
(5) "0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc" (10000.000000000000000000 ETH)
(6) "0x976EA74026E726554dB657fA54763abd0C3a0aa9" (10000.000000000000000000 ETH)
(7) "0x14dC79964da2C08b23698B3D3cc7Ca32193d9955" (10000.000000000000000000 ETH)
(8) "0x23618e81E3f5cdF7f54C3d65f7FBc0aBf5B21E8f" (10000.000000000000000000 ETH)
(9) "0xa0Ee7A142d267C1f36714E4a8F75612F20a79720" (10000.000000000000000000 ETH)

# Private Keys

(0) 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
(1) 0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d
(2) 0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a
(3) 0x7c852118294e51e653712a81e05800f419141751be58f605c371e15141b007a6
(4) 0x47e179ec197488593b187f80a00eb0da91f1b9d0b13f8733639f19c30a34926a
(5) 0x8b3a350cf5c34c9194ca85829a2df0ec3153be0318b5e2d3348e872092edffba
(6) 0x92db14e403b83dfe3df233f83dfa3a0d7096f21ca9b0d6d6b8d88b2b4ec1564e
(7) 0x4bbbf85ce3377467afe5d46f804f221813b2bb87f24d81f60f1fcdbf7cbf4356
(8) 0xdbda1821b80551c9d65939329250298aa3472ba22feea921c0cf5d620ea67b97
(9) 0x2a871d0798f97d79848a013d4936a73bf4cc922c825d33c1cf7073dff6d409c6
```

## Debugging

If you need to do manual debugging, you can use console2 print statements like:

```sol

console2.log("Hello World, a={0}, b={1}", a, b);
```

You need console2 iso console to ~+-print numbers correctly in some case due to
some update.

and run:

```sh
forge test --vv
```

to show check up to where the print statements were printed.

## msg.sender

- If function `foo` in contract `Hello` is called from a contract `Caller`,
  calls another function `bar` in contract `Hello`: they both have
  `msg.sender=caller`.
- If function `foo` in contract `Hello` is called from a contract `Caller`,
  calls another function `some` in contract `Clouds`: they the
  `msg.sender=caller` in `foo`, and `msg.sender=hello` in `some`.

In essence, the message.sender refers to the contract that calls the function,
not to the function that calls the function. So you can have 3
nested/sequential calls in with the same `msg.sender` in the same contract, but
as soon as one function is in another contract, the `msg.sender` is that of the
contract that called that function (still the same if the first call of the
chain was also in that first contract).
